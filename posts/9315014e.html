<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://babybluue.github.io/posts/9315014e"><link rel="manifest" href="/manifest.webmanifest"><link rel="apple-touch-icon" sizes="192x192" href="/images/appleicon"><link rel="apple-touch-startup-image" media="(device-width: 750px) and (device-height:1334px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)" href="/images/launch"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="babyblue"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1f1f1f"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#fff"><meta name="color-scheme" content="light dark"><link rel="icon" href="/images/favicon.ico"><meta name="description" content="默认绑定 "><meta name="keywords" content="blog,博客,程序员,记录,学习,网站 "><title>关于JavaScript里的this</title><link rel="stylesheet" href="/style/style.css"><link rel="stylesheet" href="/style/highlight.css" media="none" onload='this.media="all"'><link rel="stylesheet" href="/style/fancybox.css" media="none" onload='this.media="all"'><script type="text/javascript">var currentPath=window.location.pathname,targetUrl="https://didmax.pages.dev";window.location.href=targetUrl+currentPath</script><script>localStorage.theme&&document.documentElement.setAttribute("data-theme",localStorage.theme)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TMJ0G5Z2NR"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TMJ0G5Z2NR")</script><script>document.onreadystatechange=()=>{const t=document.querySelector(".loading-bar");700<document.body.clientWidth&&(t.style.background="#91C4E2","interactive"==document.readyState&&(t.style.transition="width 1.4s ease-in-out",t.style.width="67%"),"complete"==document.readyState&&(t.style.transition="width 0.3s ease-in-out",t.style.width="100%",setTimeout(()=>{t.setAttribute("style","transition:width 0s;width:0;background:''")},500)))}</script><meta name="generator" content="Hexo 5.4.2"></head><body class="scroll-bar"><div class="loading-bar"></div><div class="progress-bar"></div><main><header><nav><ul class="nav-button"><li></li><li></li><li></li></ul><div class="nav-bar"><ul><span class="close-button">×</span><div class="nav-avatar"><a href="/" aria-label="index"><img src="/images/avatar.png" class="avatar" alt="avatar"></a></div><li><a href="/archives/">Archive</a></li><li><a href="/notes/">Notes</a></li><li><a href="/articles/">Articles</a></li><li><a href="mailto:kerrismith19786@gmail.com" rel="external nofollow noreferrer">Contact</a></li></ul></div></nav></header><div class="post-main"><article><div class="post-card"><div class="header-title">关于JavaScript里的this</div><div class="header-info"><span>2021.03.20 Sat</span></div><div class="card-content"><h4 id="this-的两个误解"><a class="markdownIt-Anchor" href="#this-的两个误解"></a> this 的两个误解</h4><ul><li>this 指向函数自身?</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>);<br>&#125;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ul><li>this 指向函数的作用域?</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">//bar()处于foo()的作用域中</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//2</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">//undefined</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><span id="more"></span><blockquote><p>this 是在运行时绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件，this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录(执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方式、传入的参数等信息，this 就是这个记录的一个属性，会在函数执行的过程中用到。</p></blockquote><h4 id="this-的绑定规则"><a class="markdownIt-Anchor" href="#this-的绑定规则"></a> this 的绑定规则</h4><ul><li><p><strong>默认绑定</strong></p><p>无法应用其他规则时的默认规则</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>上面的例子中，this 指向的是全局对象，而 a 是声明在全局作用域中的变量，于是 this.a 即打印了变量 a 的值。当 foo()运行在严格模式下时，默认绑定不能绑定全局对象，打印结果会是 undefined</p><ul><li><p><strong>隐式绑定</strong></p><p>调用位置是否有上下文对象，或者是否被某个对象'拥有'或者'包含'。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>上例中调用位置使用 obj 上下文来引用函数，可以看成函数被调用时它就属于了 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</p><p><em>隐式丢失</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//隐式丢失</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>;<br><span class="hljs-comment">//bar实际上引用的是foo函数本身，此时的bar()是一个不带任何修饰的函数调用</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;wuhu&#x27;</span>;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">//wuhu</span><br></code></pre></td></tr></table></figure><p>同样，在将函数作为参数传递时也会发生赋值，只不过这是一种隐式赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//隐式丢失</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">//传递的函数实际的调用位置，js引擎应用默认调用规则</span><br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>: foo,<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;wuhu&#x27;</span>;<br><span class="hljs-title function_">doFoo</span>(obj.<span class="hljs-property">foo</span>); <span class="hljs-comment">//wuhu</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>显示绑定</strong></p><p>不在对象内部包含函数引用，而是在某个对象上强制调用函数，函数的 call()和 apply()方法,bind()方法</p></li></ul><p>call()和 apply()的第一个参数是用来绑定 this 的，可以直接指定 this 的绑定对象。如果传入的是一个非对象类型，比如字符串或者数字，会被转化成它的对象形式(new String()、new Number())。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-comment">//把foo的this强行绑定到obj上</span><br>foo.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>apply()和 call()作用完全一样，只是接受参数的方式不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, arg1, arg2);<br>func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [arg1, arg2]);<br></code></pre></td></tr></table></figure><p><em>硬绑定</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + somethig;<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">/*arguments 是一个函数的局部变量。</span><br><span class="hljs-comment">  它可以被用作被调用对象的所有未指定的参数。</span><br><span class="hljs-comment">  这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。</span><br><span class="hljs-comment">  你可以使用arguments来把所有的参数传递给被调用对象</span><br><span class="hljs-comment">  被调用对象接下来就负责处理这些参数。*/</span><br>&#125;;<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p>在上面的例子里，无论如何调用 bar 函数，它都会永远会返回 foo 被绑定后的结果，这种显示的强制绑定为硬绑定。</p><p>bind()函数就是为了方便硬绑定而出现的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj);<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>bind()会返回一个硬编码的新函数--它会把你指定的参数设置为 this 的上下文并调用原始函数</p><p><em>API 调用的'上下文'</em></p><p>第三方库的一些函数，JavaScript 语言和宿主环境中许多新的内置函数都提供一个可选的参数，通常被称为上下文(context),其作用和 bind()一样，确保调用函数使用指定的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;hello motherfucker&#x27;</span>,<br>&#125;;<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(foo, obj);<br><span class="hljs-comment">//1 hello... 2 hello... 3 hello...</span><br></code></pre></td></tr></table></figure><p>forEach 的第二个参数，绑定回调时函数的 this 值</p><ul><li><strong>new 绑定</strong></li></ul><p>JavaScript 里的构造函数:</p><blockquote><p>构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已，这种函数调用被称为构造函数调用。</p></blockquote><blockquote><p>实际上并不存在所谓的‘构造函数’，只有对于函数的‘构造调用’</p></blockquote><p>使用 new 来调用函数会自动执行下面的操作:</p><ol><li>创建一个全新的对象</li><li>这个新对象会被执行[Prototype]连接</li><li>这个新对象会绑定到函数调用的 this</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">a</span>); <span class="hljs-comment">//2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// foo &#123;a:2&#125;</span><br></code></pre></td></tr></table></figure></div><div class="post-tags"><a href="/tags/JavaScript/">JavaScript</a></div></div></article><div class="post-pagination"><div class="prev-page"><a href="/posts/a37770e5" title="页面阅读进度">页面阅读进度</a></div><div class="next-page"><a href="/posts/c62cf7f9" title="回到顶部与页面滚动设置 ">回到顶部与页面滚动设置</a></div></div></div><svg t="1673947892053" class="top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9313" width="45" height="45"><path d="M535.12 442.432v210.016a16 16 0 0 1-16 16h-16.16a16 16 0 0 1-16-16V440.208l-32.88 32.864a16 16 0 0 1-11.312 4.688h-28.304a14.464 14.464 0 0 1-10.24-24.688l97.824-97.808a11.136 11.136 0 0 1 15.744 0l97.808 97.808a14.464 14.464 0 0 1-10.24 24.688h-28.288a16 16 0 0 1-11.312-4.688l-30.64-30.64zM512 800c159.056 0 288-128.944 288-288s-128.944-288-288-288-288 128.944-288 288 128.944 288 288 288z m0 48c-185.568 0-336-150.432-336-336s150.432-336 336-336 336 150.432 336 336-150.432 336-336 336z" p-id="9314"></path></svg><div class="tip disappear"><p>检测到页面内容有更新，是否刷新页面 <span class="positive-btn">是</span><span class="negative-btn">否</span></p></div></main><script src="/scripts/script.js" async></script><script async type="module">import{Fancybox}from"/scripts/fancybox.esm.js";Fancybox.bind('[data-fancybox="gallery"]',{Toolbar:{display:["fullscreen","download","close"]}})</script></body></html>